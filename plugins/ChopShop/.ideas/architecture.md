# DSP Architecture: ChopShop

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (2025-12-09)
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### 1. Stutter/Buffer Capture Engine
- **JUCE Class:** Custom implementation using `juce::AudioBuffer<float>` for circular buffer
- **Purpose:** Capture audio segments at tempo-synced divisions and repeat them
- **Parameters Affected:** stutterRate (note division), triggerMode
- **Configuration:**
  - Buffer size: 4 bars at 192kHz maximum (for longest note division 1/1)
  - Calculation: `bufferSize = (sampleRate * 60.0 / bpm) * 4.0 * 4.0` (4 bars, 4 beats per bar)
  - Capture point: Triggered by mode (always/MIDI/threshold)
  - Repeat strategy: Loop buffer segment matching note division length
  - Crossfade: 5ms crossfade at loop boundaries to prevent clicks

### 2. Pitch Shifting Engine
- **JUCE Class:** Custom implementation OR third-party library (Rubber Band Library fallback)
- **Purpose:** Transpose audio by -24 to +24 semitones without time change
- **Parameters Affected:** pitchShift, linkPitchSpeed
- **Configuration:**
  - **Primary approach:** Granular synthesis (MEDIUM complexity)
    - Grain size: 50ms
    - Overlap: 75% (4x overlap for smooth crossfade)
    - Window: Hann window
    - Pitch ratio: `2.0^(semitones/12.0)`
  - **Fallback approach:** Phase vocoder (if quality insufficient)
    - FFT size: 2048 samples
    - Hop size: 512 samples (75% overlap)
    - Phase correction: Peak-locked phase coherence
  - **Linked mode:** When linkPitchSpeed=true, pitch shift is disabled (speed controls both)

### 3. Speed/Time Manipulation Engine
- **JUCE Class:** Custom implementation using variable playback rate
- **Purpose:** Change playback speed from 50% to 200% (with or without pitch change)
- **Parameters Affected:** speed, linkPitchSpeed
- **Configuration:**
  - **Independent mode (linkPitchSpeed=false):**
    - Use time-stretching algorithm (maintain pitch)
    - Granular synthesis with grain size scaling
    - Speed 100% = 1.0x playback rate
    - Speed 50% = 0.5x playback rate (slow down, maintain pitch)
    - Speed 200% = 2.0x playback rate (speed up, maintain pitch)
  - **Linked mode (linkPitchSpeed=true):**
    - Simple sample rate manipulation (pitch changes with speed)
    - Speed 50% = pitch down 1 octave (-12 semitones)
    - Speed 200% = pitch up 1 octave (+12 semitones)
    - Tape-style coupling (varispeed)

### 4. Reverse Processing
- **JUCE Class:** Custom implementation using buffer reversal
- **Purpose:** Reverse audio chunks for backwards playback effect
- **Parameters Affected:** reverse (boolean)
- **Configuration:**
  - Applied to captured buffer segment
  - Reversal happens after stutter capture, before pitch/speed processing
  - In-place reversal: `std::reverse(buffer.begin(), buffer.end())`
  - Crossfade: 5ms fade-in/out to prevent clicks when toggling

### 5. Tempo Sync System
- **JUCE Class:** `juce::AudioPlayHead` for BPM retrieval
- **Purpose:** Sync stutter rate to host tempo
- **Parameters Affected:** stutterRate (1/1 to 1/64)
- **Configuration:**
  - Query host BPM via `AudioPlayHead::getPosition()->getBpm()`
  - Calculate samples per division: `samplesPerDivision = (sampleRate * 60.0 / bpm) * (4.0 / divisionValue)`
  - Division values: 1/1=1.0, 1/2=2.0, 1/4=4.0, 1/8=8.0, 1/16=16.0, 1/32=32.0, 1/64=64.0
  - Fallback: If no BPM from host, default to 120 BPM

### 6. MIDI Trigger System
- **JUCE Class:** `juce::MidiBuffer`, `juce::MidiMessage`
- **Purpose:** Trigger stutter capture on MIDI note-on events
- **Parameters Affected:** triggerMode (when set to "MIDI")
- **Configuration:**
  - Accept MIDI input (requires `NEEDS_MIDI_INPUT TRUE` in CMakeLists.txt)
  - Listen for any note-on message (omni mode, all channels)
  - Note number and velocity ignored (any note triggers)
  - Trigger action: Capture current buffer segment and start stutter loop
  - Retrigger behavior: New note-on restarts capture (replaces current buffer)

### 7. Transient Detection System
- **JUCE Class:** Custom implementation using dual envelope followers
- **Purpose:** Automatically trigger stutter on transient peaks
- **Parameters Affected:** triggerMode (when set to "Threshold"), threshold (dB)
- **Configuration:**
  - **Dual envelope follower design:**
    - Fast envelope: 1ms attack, 10ms release
    - Slow envelope: 50ms attack, 200ms release
  - **Detection algorithm:**
    - Convert to dB: `fastDB = 20.0 * log10(fastEnv)`, `slowDB = 20.0 * log10(slowEnv)`
    - Difference: `delta = fastDB - slowDB`
    - Trigger when: `delta > threshold`
  - **Threshold parameter:** -60dB to 0dB (user-adjustable sensitivity)
  - **Threshold-independent:** Detects transients at any level (algorithm detects rate of change, not absolute level)
  - **Hysteresis:** 3dB hysteresis to prevent re-triggering on decay

### 8. Reorderable Effect Chain
- **JUCE Class:** Custom routing using effect order array
- **Purpose:** User can reorder stutter, pitch, speed, reverse in any order
- **Parameters Affected:** chainOrder (string, e.g., "0,1,2,3")
- **Configuration:**
  - **Effect indices:**
    - 0 = Stutter
    - 1 = Pitch Shift
    - 2 = Speed
    - 3 = Reverse
  - **Default order:** "0,1,2,3" (Stutter → Pitch → Speed → Reverse)
  - **Storage:** Comma-separated string stored in APVTS or ValueTree
  - **Processing:** Parse order string and apply effects in sequence
  - **UI interaction:** Drag-and-drop in UI updates order string (headless mode: not implemented yet)

### 9. Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend processed (wet) signal with unprocessed (dry) signal
- **Parameters Affected:** mix (0-100%)
- **Configuration:**
  - Mix 0% = 100% dry (bypass effect chain)
  - Mix 100% = 100% wet (full effect)
  - Latency compensation: DryWetMixer handles delay alignment automatically
  - Push dry signal before processing, pop after wet processing

---

## Processing Chain

```
Input (Stereo)
  ↓
Dry/Wet Mixer (capture dry) ← MIX parameter
  ↓
[TRIGGER DETECTION] ← triggerMode, threshold, MIDI input
  ↓ (on trigger)
BUFFER CAPTURE (tempo-synced segment) ← stutterRate, tempo from host
  ↓
[REORDERABLE EFFECT CHAIN] ← chainOrder parameter
  │
  ├─ Effect 0: Stutter (repeat captured buffer)
  ├─ Effect 1: Pitch Shift ← pitchShift, linkPitchSpeed
  ├─ Effect 2: Speed ← speed, linkPitchSpeed
  └─ Effect 3: Reverse ← reverse
  │
  ↓ (order configurable via chainOrder)
Dry/Wet Mixer (blend) ← MIX parameter
  ↓
Output (Stereo)
```

**Routing notes:**
- Trigger modes are mutually exclusive (always/MIDI/threshold)
- Effect chain order is dynamic based on chainOrder parameter
- Link Pitch/Speed mode disables independent time-stretching (uses varispeed instead)
- Reverse can be placed anywhere in chain (default: last)

---

## System Architecture

### MIDI Routing

**Input handling:** Accepts MIDI input for trigger mode

**Note mapping:**
- Any MIDI note-on message triggers stutter capture
- Note number: Ignored (omni trigger)
- Velocity: Ignored (all velocities trigger equally)
- Channel: Omni mode (responds to all channels)

**JUCE classes:**
- `juce::MidiBuffer` - MIDI event storage
- `juce::MidiMessage::isNoteOn()` - Note-on detection

**Processing:**
- MIDI messages processed in `processBlock()` on audio thread
- Note-on triggers buffer capture and stutter loop restart
- No note-off handling (stutter continues until next trigger or mode change)

---

### State Persistence

**What state is saved:**
- APVTS parameters: stutterRate, pitchShift, speed, linkPitchSpeed, reverse, triggerMode, threshold, mix (automatic)
- Custom state:
  - chainOrder (effect chain order string)

**Serialization format:**
- APVTS: XML via ValueTree (automatic)
- Custom state: ValueTree with structure:
  ```xml
  <PluginState>
    <EffectChain order="0,1,2,3"/>
  </PluginState>
  ```

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - APVTS automatic persistence
- `juce::ValueTree` - Custom state tree for chain order

**Restore behavior:**
- Invalid chain order: Use default "0,1,2,3"
- Missing parameters: Use defaults from parameter spec

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| stutterRate | Choice | 1/1, 1/2, 1/4, 1/8, 1/16, 1/32, 1/64 | Stutter Engine | Note division for buffer capture length |
| pitchShift | Float | -24.0 to 24.0 | Pitch Shift Engine | Semitone transposition |
| speed | Float | 50.0 to 200.0 | Speed Engine | Playback speed percentage |
| linkPitchSpeed | Bool | 0/1 | Pitch + Speed Engines | Couple pitch/speed (tape mode) |
| reverse | Bool | 0/1 | Reverse Processing | Reverse audio chunks |
| triggerMode | Choice | Always, MIDI, Threshold | Trigger System | How stuttering is activated |
| threshold | Float | -60.0 to 0.0 | Transient Detection | Sensitivity for threshold trigger (dB) |
| mix | Float | 0.0 to 100.0 | Dry/Wet Mixer | Wet proportion (0.0-1.0 internally) |
| chainOrder | String | - | Effect Chain Router | Order of effects (e.g., "0,1,2,3") |

---

## Algorithm Details

### Stutter/Buffer Capture

**Algorithm:** Circular buffer with tempo-synced segment capture and repeat

**Implementation notes:**
- Buffer size calculation: `maxBufferSize = (sampleRate * 60.0 / minBPM) * 4.0 * 4.0` (4 bars at 40 BPM minimum)
- Capture trigger: Based on triggerMode (always/MIDI/threshold)
- Segment length: `segmentLength = (sampleRate * 60.0 / bpm) * (4.0 / divisionValue)`
- Loop playback: Repeat segment with 5ms crossfade at loop boundaries
- Crossfade formula: Linear fade-out last 5ms, linear fade-in first 5ms

### Pitch Shifting (Granular Synthesis)

**Algorithm:** Grain-based pitch shifting with overlap-add

**Implementation notes:**
- Grain size: 50ms (2400 samples at 48kHz)
- Overlap: 75% (4x overlap, grains spaced 12.5ms apart)
- Window: Hann window `w(n) = 0.5 * (1 - cos(2π * n / grainSize))`
- Pitch ratio: `ratio = 2.0^(semitones/12.0)`
- Grain read position increment: `readIncrement = ratio` (faster for upshift, slower for downshift)
- Output synthesis: Overlap-add with 4 concurrent grains

### Speed Manipulation (Time-Stretching)

**Algorithm:** Variable playback rate with optional time-stretching

**Implementation notes:**
- **Independent mode (linkPitchSpeed=false):**
  - Granular time-stretching (similar to pitch shift but without pitch change)
  - Grain size scaling: Larger grains for slower speeds
  - Output rate matches input rate (maintains pitch)
- **Linked mode (linkPitchSpeed=true):**
  - Simple sample rate manipulation: `playbackRate = speed / 100.0`
  - No time-stretching (pitch changes naturally with speed)
  - Speed 50% = pitch down 1 octave
  - Speed 200% = pitch up 1 octave

### Transient Detection (Dual Envelope Follower)

**Algorithm:** Difference between fast and slow envelope followers

**Implementation notes:**
- **Fast envelope follower:**
  - Attack coefficient: `attackCoeff = exp(-1.0 / (sampleRate * 0.001))` (1ms)
  - Release coefficient: `releaseCoeff = exp(-1.0 / (sampleRate * 0.010))` (10ms)
  - Update: `env = (input > env) ? attackCoeff * env + (1-attackCoeff) * input : releaseCoeff * env + (1-releaseCoeff) * input`
- **Slow envelope follower:**
  - Attack: 50ms, Release: 200ms (same coefficient formula)
- **Difference calculation:**
  - `fastDB = 20.0 * log10(max(fastEnv, 1e-6))` (avoid log(0))
  - `slowDB = 20.0 * log10(max(slowEnv, 1e-6))`
  - `delta = fastDB - slowDB`
- **Trigger condition:**
  - Trigger when: `delta > threshold && !triggered`
  - Reset when: `delta < (threshold - 3.0)` (3dB hysteresis)

### Reverse Processing

**Algorithm:** In-place buffer reversal

**Implementation notes:**
- Apply to captured buffer segment
- Reversal: `std::reverse(bufferStart, bufferEnd)`
- Crossfade: 5ms fade-in/out when toggling reverse on/off
- No additional processing (simple pointer reversal)

---

## Integration Points

### Feature Dependencies

- **Stutter Engine → Effect Chain:** Captured buffer is input to effect chain
- **Trigger System → Stutter Engine:** Trigger events control when buffer capture occurs
- **Tempo Sync → Stutter Engine:** Host BPM determines buffer segment length
- **Link Pitch/Speed → Pitch + Speed Engines:** When linked, speed controls both (pitch shift disabled)
- **Effect Chain Order → All Effects:** chainOrder parameter determines signal routing sequence
- **Dry/Wet Mixer → All Effects:** Dry signal captured before processing, blended after

---

### Parameter Interactions

- **linkPitchSpeed affects pitch and speed engines:**
  - When true (linked): Pitch shift engine bypassed, speed engine uses varispeed (pitch changes with speed)
  - When false (independent): Pitch shift engine active, speed engine uses time-stretching (pitch unchanged)
  - Trade-off: Linked mode is tape-style (simpler, lower CPU), independent mode is professional (complex, higher CPU)

- **triggerMode determines which trigger system is active:**
  - Always: Stutter continuously (no trigger needed)
  - MIDI: MIDI note-on triggers capture
  - Threshold: Transient detection triggers capture
  - Mutually exclusive (only one mode active at a time)

- **chainOrder affects signal flow:**
  - Default "0,1,2,3": Stutter → Pitch → Speed → Reverse
  - Changing order changes sound character:
    - Pitch before stutter: Pitch-shifted source stutters
    - Stutter before pitch: Stuttered audio then pitch-shifted
  - Some orders may produce unexpected artifacts (e.g., reverse before stutter)

---

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Capture dry signal:** Store unprocessed input for dry/wet mixing
   - Must happen first to preserve clean input

2. **Trigger detection:** Check trigger mode and conditions
   - Always mode: Always trigger
   - MIDI mode: Check for note-on messages
   - Threshold mode: Run dual envelope follower and check threshold

3. **Buffer capture (on trigger):** Capture tempo-synced segment of input
   - Segment length determined by stutterRate and host BPM
   - Store in circular buffer for repeat playback

4. **Reorderable effect chain:** Apply effects in order specified by chainOrder
   - Parse chainOrder string (e.g., "0,1,2,3")
   - For each effect index in order:
     - 0: Stutter (repeat buffer segment)
     - 1: Pitch Shift (granular synthesis or varispeed)
     - 2: Speed (time-stretching or varispeed)
     - 3: Reverse (buffer reversal)

5. **Blend with dry signal:** Mix processed output with captured dry signal
   - Dry/wet proportion controlled by mix parameter (0-100%)

**Why order matters:**
- Dry capture first: Prevents latency-corrupted dry signal in dry/wet mix
- Trigger detection before capture: Determines when buffer is captured
- Effect chain order affects sound character (user-configurable)
- Dry/wet blend last: Ensures all processing is complete before mixing

---

### Thread Boundaries

**Audio thread:**
- All DSP processing (stutter, pitch, speed, reverse, dry/wet mix)
- Trigger detection (MIDI, threshold, always)
- Buffer capture and playback
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- chainOrder updates (string parameter)
- Preset loading/saving
- UI repaints (if UI implemented)

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

---

## Implementation Risks

### Pitch Shifting Engine

**Complexity:** HIGH
- Granular synthesis is algorithmically complex
- Phase vocoder is even more complex (fallback)
- Wide pitch range (-24 to +24 semitones) increases artifact risk

**Risk Level:** HIGH

**Risk factors:**
1. Granular synthesis artifacts
   - Graininess audible at large pitch shifts (>12 semitones)
   - Overlapping grains can cause phasing
2. High CPU usage
   - 4x overlap with 50ms grains = significant processing
   - Estimated 30-40% single core
3. Latency
   - Grain size (50ms) introduces latency
   - Requires latency compensation via `getLatencySamples()`

**Alternative approaches:**
1. **Phase vocoder:**
   - Complexity: VERY HIGH
   - Quality: Higher than granular (professional-grade)
   - CPU: ~40-60% single core
   - Best for: If granular artifacts unacceptable

2. **Simple resampling (linked mode only):**
   - Complexity: LOW
   - Quality: Perfect (pitch changes naturally with speed)
   - CPU: ~5% single core
   - Best for: When linkPitchSpeed=true

3. **Third-party library (Rubber Band Library):**
   - Complexity: LOW (integration)
   - Quality: High (industry-standard)
   - Licensing: GPL or commercial license required
   - Best for: If custom implementation fails

**Fallback architecture:**
- **Primary:** Granular synthesis (moderate complexity, acceptable quality)
- **Fallback 1:** If granular artifacts unacceptable → Phase vocoder (high complexity, high quality)
- **Fallback 2:** If phase vocoder too complex → Rubber Band Library (external dependency)
- **Fallback 3:** If all pitch shifting fails → Linked mode only (speed controls pitch)

**Mitigation strategy:**
1. Start with linked mode (varispeed) to validate concept (LOW risk)
2. Implement granular synthesis for independent pitch shift (MEDIUM risk)
3. Tune grain size, overlap, and window function to minimize artifacts
4. Benchmark CPU usage early (may need quality modes)
5. Consider Rubber Band Library if custom implementation too complex

---

### Reorderable Effect Chain

**Complexity:** MEDIUM
- Dynamic routing based on user configuration
- Effect order changes signal flow significantly
- State persistence for chainOrder string

**Risk Level:** MEDIUM

**Risk factors:**
1. Order-dependent artifacts
   - Some effect orders may produce unexpected sounds
   - Reverse before pitch shift: Artifacts differ from pitch before reverse
   - Difficult to predict all order combinations
2. Routing complexity
   - Need flexible signal flow architecture
   - Effect indices must map correctly to processing functions
3. UI complexity (future)
   - Drag-and-drop reordering requires JavaScript ↔ C++ communication
   - Headless mode for initial testing (no reordering UI)

**Alternative approaches:**
1. **Fixed effect chain:**
   - Complexity: LOW
   - Order: Stutter → Pitch → Speed → Reverse (fixed)
   - Limitation: No user control over order
   - Best for: Simplicity, predictable behavior

2. **Limited reordering (presets):**
   - Complexity: MEDIUM
   - Options: 3-4 preset orders (e.g., "Normal", "Reverse First", "Pitch First")
   - Benefit: Predictable, tested orders
   - Best for: Balance between flexibility and complexity

**Fallback architecture:**
- **Primary:** Reorderable chain with string parameter (chainOrder)
- **Fallback 1:** If routing complexity too high → Fixed chain order
- **Fallback 2:** If user needs flexibility → Preset order options (3-4 fixed orders)

**Mitigation strategy:**
1. Implement fixed chain order first (validate individual effects)
2. Add reorderable routing as enhancement
3. Test all order permutations (4! = 24 possible orders)
4. Document which orders sound best in presets
5. Defer UI drag-and-drop to later stage (use chainOrder string for now)

---

### Stutter/Buffer Capture Engine

**Complexity:** MEDIUM
- Tempo sync requires BPM from host
- Circular buffer management
- Crossfade at loop boundaries

**Risk Level:** MEDIUM

**Risk factors:**
1. Tempo sync reliability
   - Not all hosts provide reliable BPM
   - BPM changes during playback (tempo automation)
   - Requires fallback to fixed tempo
2. Buffer allocation size
   - Worst case: 4 bars at 40 BPM @ 192kHz = ~460k samples (~1.8MB)
   - Allocation in prepareToPlay (safe)
3. Crossfade clicks
   - Incorrect crossfade implementation causes clicks at loop boundaries
   - Requires careful fade curve design

**Alternative approaches:**
1. **Fixed-time stutter (no tempo sync):**
   - Complexity: LOW
   - Parameters: Stutter length in milliseconds (e.g., 50ms, 100ms, 200ms)
   - Limitation: Not synced to host tempo
   - Best for: If tempo sync unreliable

2. **Simpler trigger modes (no threshold detection):**
   - Complexity: LOW
   - Modes: Always, MIDI only (no transient detection)
   - Limitation: Less flexible triggering
   - Best for: Reducing DSP complexity

**Fallback architecture:**
- **Primary:** Tempo-synced stutter with all three trigger modes
- **Fallback 1:** If tempo sync unreliable → Fixed-time stutter (milliseconds instead of divisions)
- **Fallback 2:** If threshold detection too complex → Always + MIDI modes only

**Mitigation strategy:**
1. Check juce8-critical-patterns.md for AudioPlayHead best practices
2. Test with multiple hosts (Logic Pro, Ableton, FL Studio, Reaper)
3. Implement BPM fallback (default to 120 BPM if host doesn't provide)
4. Use linear crossfade (simple, effective)
5. Allocate buffer in prepareToPlay, not in constructor

---

### Overall Project Risk

**Overall complexity:** HIGH
- Pitch shifting (HIGH) + reorderable chain (MEDIUM) + stutter engine (MEDIUM)
- 3 medium-to-high complexity features with interdependencies
- No file I/O or multi-output (simplifies overall)

**Highest risk component:** Pitch Shifting Engine
- Represents ~50% of project risk
- Most algorithmically complex
- Highest CPU cost and artifact risk
- Wide pitch range (-24 to +24 semitones) is ambitious

**Recommended approach:**
1. **Phase 1 - Validate concept:** Implement stutter engine with linked mode (varispeed, LOW risk)
2. **Phase 2 - Build foundation:** Implement trigger modes (MIDI, threshold) and dry/wet mix (MEDIUM risk)
3. **Phase 3 - Add effects:** Implement granular pitch shift and independent speed (HIGH risk)
4. **Phase 4 - Polish:** Implement reorderable chain, optimize CPU, reduce artifacts
5. **Phase 5 - Fallback testing:** If granular fails, implement phase vocoder or Rubber Band Library

---

## Architecture Decisions

### Pitch Shifting Algorithm Choice

**Decision:** Use granular synthesis for pitch shifting (not phase vocoder)

**Rationale:**
- Granular synthesis is MEDIUM complexity (phase vocoder is VERY HIGH)
- Acceptable quality for stutter/glitch effect (artifacts are part of aesthetic)
- Lower CPU usage than phase vocoder (~30% vs ~50% single core)
- Easier to implement and tune
- Industry examples use granular for glitch effects (iZotope Stutter Edit)

**Alternatives considered:**
1. **Phase vocoder:**
   - Why rejected: Too complex for initial implementation, higher CPU cost
   - When to reconsider: If granular artifacts unacceptable for all use cases

2. **Rubber Band Library:**
   - Why rejected: External dependency, GPL licensing complexity
   - When to reconsider: If custom implementation fails or takes too long

3. **Linked mode only (no independent pitch shift):**
   - Why rejected: Reduces plugin value (no independent pitch control)
   - When to reconsider: If all pitch shifting approaches fail

**Tradeoffs accepted:**
- **Graininess artifacts:** Granular synthesis has audible grain texture at large shifts (>12 semitones)
  - Acceptable because: Glitch effect embraces artifacts, not transparent pitch shift
- **Lower quality than professional pitch shifters:** Not as clean as Melodyne or Auto-Tune
  - Acceptable because: Plugin is for creative destruction, not pitch correction
- **Latency:** 50ms grain size = 50ms latency
  - Acceptable because: Stutter effect already has buffer latency, not real-time tracking use

**When to revisit:**
- If CPU usage exceeds 50% single core (reduce grain overlap or size)
- If artifacts unacceptable in user testing (consider phase vocoder)
- If implementation too complex (consider Rubber Band Library)

---

### Link Pitch/Speed Design

**Decision:** Implement two modes - linked (varispeed) and independent (time-stretching)

**Rationale:**
- Linked mode (tape-style) is user expectation for "link" toggle
- Independent mode offers professional flexibility (pitch without speed change)
- Two modes cover both creative (linked) and precise (independent) use cases
- Lower CPU in linked mode (simple resampling)

**Alternatives considered:**
1. **Linked mode only (no independent pitch/speed):**
   - Why rejected: Reduces flexibility, limits creative options
   - When to reconsider: If time-stretching proves too complex

2. **Independent mode only (no linked/tape mode):**
   - Why rejected: User expectation for "link" toggle is tape-style coupling
   - When to reconsider: Never (linked mode is industry standard)

**Tradeoffs accepted:**
- **Complexity:** Two processing paths (linked vs independent) increases code complexity
  - Acceptable because: Clear separation, no shared state
- **Parameter interaction:** linkPitchSpeed affects both pitch and speed engines
  - Acceptable because: Interaction is intuitive (toggle switches modes)

---

### Reorderable Effect Chain Design

**Decision:** Implement reorderable chain with string parameter (chainOrder)

**Rationale:**
- Unique feature differentiator (not common in stutter plugins)
- Users can experiment with effect order for creative sound design
- String parameter is simple to persist and restore
- Can defer UI drag-and-drop to later stage (use string parameter for now)

**Alternatives considered:**
1. **Fixed effect chain:**
   - Why rejected: Reduces creative flexibility, less competitive
   - When to reconsider: If routing complexity causes implementation issues

2. **Preset order options:**
   - Why rejected: Arbitrary limitation, doesn't cover all possibilities
   - When to reconsider: If reorderable chain proves too complex

**Tradeoffs accepted:**
- **Order-dependent artifacts:** Some effect orders may sound unexpected
  - Acceptable because: Creative effect, experimentation is encouraged
- **Routing complexity:** Dynamic signal flow based on parameter string
  - Acceptable because: Implementation is manageable with switch/case or function pointers
- **No UI for reordering (initially):** Headless mode uses string parameter
  - Acceptable because: UI can be added later, core functionality works via parameter

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()`
- Buffer capture and playback happen in audio thread (no allocations)
- Trigger detection (MIDI, threshold) runs in audio thread (real-time safe)
- chainOrder string parsing cached (not parsed every processBlock)

### Performance
- **Stutter engine:** ~10% CPU (buffer management, crossfade)
- **Granular pitch shift:** ~30-40% CPU (4x overlap, windowing, resampling)
- **Time-stretching (independent mode):** ~20-30% CPU (granular synthesis)
- **Linked mode (varispeed):** ~5% CPU (simple resampling)
- **Transient detection:** ~5% CPU (dual envelope followers)
- **Total estimated (worst case):** ~80% single core at 48kHz (all effects active, independent mode)
- **Total estimated (best case):** ~30% single core (linked mode, no transient detection)

### Denormal Protection
- Use `juce::ScopedNoDenormals` in processBlock()
- Envelope followers use floor value (`max(env, 1e-6)`) to prevent denormals
- Granular synthesis uses Hann window (never reaches exact zero)

### Sample Rate Handling
- Buffer size recalculated in prepareToPlay() with new sample rate
- Tempo sync uses sample rate for time-to-samples conversion
- Envelope follower coefficients recalculated on sample rate change
- Granular synthesis grain size scaled by sample rate

### Latency
- **Stutter buffer:** Variable latency based on stutterRate (e.g., 1/8 note at 120 BPM = 250ms)
- **Granular pitch shift:** 50ms grain size = 50ms latency
- **Time-stretching:** 50ms grain size = 50ms latency
- **Total latency (worst case):** ~300ms (stutter + pitch + speed)
- Report total via `getLatencySamples()` for host compensation
- DryWetMixer handles latency compensation for dry signal automatically

---

## Research References

### Professional Plugins

1. **dBlue Glitch 2** (illformed)
   - Classic stutter/glitch plugin
   - Multi-effect sequencer with tempo sync
   - Observed: Step-sequenced effects, buffer-based stutter
   - Reference: [Artists in DSP - Best Glitch VST Plugins 2025](https://artistsindsp.com/the-9-best-glitch-vst-plugins-in-2025/)

2. **Effectrix 2** (Sugar Bytes)
   - Step-sequenced multi-effect with 14 effects
   - Tempo-synced stutter and grain engine
   - Observed: Modulation system, pattern switching
   - Reference: [Artists in DSP - Best Glitch VST Plugins 2025](https://artistsindsp.com/the-9-best-glitch-vst-plugins-in-2025/)

3. **Stutter Edit 2** (iZotope/BT)
   - MIDI-triggered gesture-based stutter
   - Buffer manipulation and pitch shifting
   - Observed: Performance-oriented, gesture macros
   - Reference: [Artists in DSP - Best Glitch VST Plugins 2025](https://artistsindsp.com/the-9-best-glitch-vst-plugins-in-2025/)

4. **DFX Buffer Override** (Destroy FX)
   - Buffer-based stutter and pitch manipulation
   - MIDI-playable stutter control
   - Observed: Simple buffer override technique
   - Reference: [VST Warehouse - Free Stutter Plugins](https://vstwarehouse.com/stutter/)

### JUCE Documentation

- **juce::AudioBuffer<float>:** Circular buffer for stutter capture
- **juce::AudioPlayHead:** Host BPM retrieval for tempo sync
- **juce::MidiBuffer / juce::MidiMessage:** MIDI input for trigger mode
- **juce::dsp::DryWetMixer:** Latency-compensated dry/wet mixing
- **juce::ScopedNoDenormals:** Denormal protection

### Technical Resources

- **Time Stretching and Pitch Shifting Overview** (Stephan Bernsee)
  - Phase vocoder and granular synthesis techniques
  - Reference: [Stephan Bernsee's Blog](http://blogs.zynaptiq.com/bernsee/time-pitch-overview/)

- **Transient Detection Using Dual Envelope Followers** (KVR Audio Forums)
  - Threshold-independent transient detection
  - Fast/slow envelope difference method
  - Reference: [KVR Audio - Transient Detection](https://www.kvraudio.com/forum/viewtopic.php?t=573295)

- **Granular Synthesis for Pitch Shifting** (Audio Processing Research)
  - Grain-based pitch shifting with overlap-add
  - Hann window and grain size considerations
  - Reference: [Time Stretching Wikipedia](https://en.wikipedia.org/wiki/Audio_time_stretching_and_pitch_scaling)

---

## Notes

- Headless/minimal UI for initial testing (no designed mockup needed per user request)
- Reorderable chain UI deferred (use chainOrder string parameter)
- Linked mode (varispeed) is simpler fallback if independent pitch/speed too complex
- Granular synthesis chosen over phase vocoder for balance of quality and complexity
- Transient detection uses threshold-independent dual envelope method
- All trigger modes (always/MIDI/threshold) implemented for maximum flexibility
