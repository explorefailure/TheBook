# DSP Architecture: WaveFolder

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (2025-12-12)
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Wave Folding Engine
- **JUCE Class:** `juce::dsp::WaveShaper<float>` with custom transfer functions
- **Purpose:** Apply wave folding distortion to audio signal with cascaded stages
- **Parameters Affected:** FOLD, STAGES, MODE
- **Configuration:**
  - Three transfer function modes (Clean, Warm, Aggressive)
  - 1-4 cascaded stages (sequential application)
  - FOLD (0-100%) controls pre-gain before folding threshold
  - Each stage applies folding independently

### Oversampling System
- **JUCE Class:** `juce::dsp::Oversampling<float>`
- **Purpose:** Reduce aliasing artifacts from nonlinear wave folding
- **Parameters Affected:** None (automatic)
- **Configuration:**
  - 4x oversampling recommended (balance quality vs. CPU)
  - filterHalfBandFIREquiripple (better aliasing suppression than IIR)
  - Apply to entire wave folding chain (all stages)
  - Note: Potential gain change from oversampling filters (~6dB), compensate in output

### DC Offset Removal
- **JUCE Class:** `juce::dsp::IIR::Filter<float>` (high-pass, 20Hz cutoff)
- **Purpose:** Remove DC offset introduced by asymmetric folding modes
- **Parameters Affected:** None (always active)
- **Configuration:**
  - First-order high-pass filter at 20Hz
  - Processes output of wave folding chain
  - Prevents DC buildup from Aggressive mode asymmetry

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend unprocessed (dry) and folded (wet) signals
- **Parameters Affected:** MIX
- **Configuration:**
  - MIX (0-100%) maps to wet proportion (0.0-1.0)
  - Latency-compensated mixing (handles oversampling delay)
  - Captures dry signal before oversampling

---

## Processing Chain

```
Input (Stereo)
  ↓
Dry/Wet Mixer (capture dry)
  ↓
Oversampling (Upsample 4x) ← FOLD, STAGES, MODE affect oversampled path
  ↓
Pre-Gain (FOLD parameter) ← FOLD: 0-100% → gain 1.0-10.0
  ↓
Stage 1: Wave Folding ← MODE selects transfer function
  ↓
[Stage 2: Wave Folding] ← If STAGES ≥ 2
  ↓
[Stage 3: Wave Folding] ← If STAGES ≥ 3
  ↓
[Stage 4: Wave Folding] ← If STAGES = 4
  ↓
DC Offset Removal (20Hz HPF)
  ↓
Oversampling (Downsample to original rate)
  ↓
Dry/Wet Mixer (blend) ← MIX parameter
  ↓
Output (Stereo)
```

**Routing notes:**
- Dry signal captured before oversampling (preserves phase alignment)
- All folding stages operate on oversampled signal (reduces aliasing)
- DC removal happens in oversampled domain (more effective filtering)
- Dry/wet mixing happens after downsampling (preserves dry signal quality)

---

## System Architecture

No additional system architecture needed. WaveFolder is a pure DSP effect with no file I/O, multi-output routing, MIDI handling, or complex state persistence beyond standard APVTS parameters.

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| FOLD | Float | 0-100% | Pre-Gain | Maps to gain 1.0-10.0 (linear scaling) |
| STAGES | Choice | 1, 2, 3, 4 | Wave Folding Engine | Number of cascaded folding stages |
| MODE | Choice | 0, 1, 2 | Wave Folding Engine | Transfer function: Clean (0), Warm (1), Aggressive (2) |
| MIX | Float | 0-100% | Dry/Wet Mixer | Wet proportion (0.0-1.0 normalized) |

---

## Algorithm Details

### Wave Folding Transfer Functions

**Common principle:** All modes reflect signal back when it exceeds threshold (±1.0), creating "folds" that generate harmonics.

#### Clean Mode (Pure Mathematical)
**Algorithm:** Piecewise linear reflection
```
output = abs(fmod(input + 1.0, 4.0) - 2.0) - 1.0
```
**Implementation notes:**
- Precise, symmetrical folding
- Sharp folds create bright, precise harmonics
- Minimal added color beyond harmonic generation
- Best for drums requiring clarity and punch

#### Warm Mode (Soft-Knee + Saturation)
**Algorithm:** Hyperbolic tangent with soft-knee threshold
```
threshold = 0.9 (soft knee starts here)
if (abs(input) < threshold):
    output = input
else:
    fold_amount = (abs(input) - threshold) / (1.0 - threshold)
    output = sign(input) * (threshold + (1.0 - threshold) * tanh(fold_amount * 3.0))
```
**Implementation notes:**
- Smooth transition into folding (no sharp corners)
- Tanh saturation adds warmth and even harmonics
- Musicality from soft-knee behavior
- Best for snares and tonal percussion

#### Aggressive Mode (Hard Folding + Asymmetry)
**Algorithm:** Hard folding with asymmetric bias
```
biased_input = input + 0.15  // Asymmetric offset
output = abs(fmod(biased_input + 1.0, 4.0) - 2.0) - 1.0
output = output * 1.1  // Gain boost for bite
```
**Implementation notes:**
- Hard folds create harsh, bright character
- Asymmetric bias adds even harmonics and DC offset
- Gain boost emphasizes aggressive quality
- Best for hi-hats and metallic textures
- Requires DC removal (handled by HPF)

### Pre-Gain Calculation
**Formula:** `gain = 1.0 + (foldValue * 9.0)` where foldValue is 0.0-1.0 from FOLD parameter
- 0% FOLD → gain 1.0 (no folding)
- 25% FOLD → gain 3.5 (subtle folding)
- 50% FOLD → gain 5.5 (moderate folding)
- 100% FOLD → gain 10.0 (extreme folding)

### Multi-Stage Cascading
**Pattern:** Sequential application of same transfer function
```
signal = input
for (int stage = 0; stage < stagesValue; ++stage)
    signal = applyTransferFunction(signal, modeValue)
output = signal
```
**Behavior:**
- 1 stage: Basic folding
- 2 stages: Double the harmonic complexity (exponential growth)
- 3 stages: Very dense harmonics
- 4 stages: Extreme harmonic density (potential noise-like character)

---

## Integration Points

### Feature Dependencies

- **Oversampling → Wave Folding:** Oversampling must upsample before folding (reduces aliasing)
- **Wave Folding → DC Removal:** DC removal must process after folding (removes DC offset)
- **DC Removal → Downsampling:** DC removal in oversampled domain (more effective filtering)
- **Pre-Gain → Folding Stages:** Pre-gain amplifies signal before all stages
- **All Stages → Dry/Wet Mixer:** Wet signal is complete folding chain output

### Parameter Interactions

- **FOLD affects all STAGES equally:**
  - Pre-gain applied once before first stage
  - All stages receive same amplification
  - Higher FOLD with more STAGES = exponentially more harmonics

- **STAGES exponentially increases harmonic density:**
  - 1 stage → Fundamental + low harmonics
  - 2 stages → Squared harmonic density
  - 3 stages → Cubed harmonic density
  - 4 stages → Extreme density (may sound noisy at high FOLD)

- **MODE doesn't affect other parameters:**
  - Independent transfer function selection
  - No interaction with FOLD or STAGES
  - Only Clean mode is perfectly symmetrical (no DC)

- **MIX is post-processing:**
  - Does NOT affect folding intensity
  - Blends dry and wet signals linearly
  - 0% = bypass, 100% = full effect

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Capture dry signal:** Store unprocessed input for later mixing
   - Must happen first to preserve clean input

2. **Upsample to 4x:** Apply oversampling filter chain
   - Prepares signal for nonlinear processing

3. **Apply pre-gain:** Multiply signal by FOLD-derived gain (1.0-10.0)
   - Amplifies before folding threshold

4. **Stage 1: Apply transfer function:** First folding stage
   - All modes process this stage

5. **Stage 2-4: Apply transfer function (if enabled):** Additional cascaded stages
   - Conditional based on STAGES parameter
   - Each stage uses same transfer function (mode)

6. **DC offset removal:** Apply 20Hz high-pass filter
   - Removes DC bias from Aggressive mode
   - Operates in oversampled domain

7. **Downsample to original rate:** Apply anti-aliasing filter chain
   - Returns to host sample rate

8. **Blend with dry signal:** Mix processed (wet) with original (dry)
   - Final output controlled by MIX parameter

**Why order matters:**
- Pre-gain before folding: Determines folding intensity (not post-gain)
- Oversampling before folding: Prevents aliasing from nonlinear processing
- DC removal before downsampling: More effective filtering at higher rate
- Dry capture first: Prevents latency/phase corruption in dry signal

### Thread Boundaries

**Audio thread:**
- All DSP processing (oversampling, folding, DC removal, dry/wet mix)
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Sample-by-sample processing in processBlock()

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

---

## Implementation Risks

### Wave Folding Algorithm Implementation

**Complexity:** LOW
- Well-understood mathematical operations (abs, fmod, tanh)
- Sample-by-sample processing (no state)
- No FFT or complex signal processing

**Risk Level:** LOW

**Risk factors:**
1. Transfer functions are simple math (no algorithmic complexity)
2. Multiple example implementations available (JUCE tutorials, modular community)
3. No external dependencies beyond JUCE DSP module

**Alternative approaches:**
1. **JUCE WaveShaper with std::function:** Complexity LOW, flexible, standard approach
2. **Custom sample-by-sample loop:** Complexity LOW, more control, no WaveShaper overhead
3. **Lookup table (LUT):** Complexity MEDIUM, fastest CPU, requires precomputation

**Fallback architecture:**
- **Primary:** JUCE WaveShaper with lambda transfer functions (clean, standard)
- **Fallback 1:** Custom inline processing if WaveShaper has issues (unlikely)
- **Fallback 2:** Single mode only (Clean) if multiple modes prove problematic (unlikely)

**Mitigation strategy:**
1. Prototype transfer functions in JUCE AudioPluginDemo first
2. Test aliasing with sine sweep + spectrum analyzer
3. Verify DC offset levels with DC meter plugin
4. Benchmark CPU with 1 stage, then 4 stages

---

### Oversampling Implementation

**Complexity:** MEDIUM
- JUCE provides dsp::Oversampling class (reduces implementation complexity)
- Configuration requires understanding upsample/downsample process
- Gain compensation may be needed

**Risk Level:** MEDIUM

**Risk factors:**
1. JUCE Oversampling class has reported gain issues (~6dB boost with FIR)
2. CPU usage increases linearly with oversampling factor (4x = 4x CPU)
3. Latency increases with oversampling (filter delay + processing delay)
4. Not all use cases require oversampling (low FOLD amounts have minimal aliasing)

**Alternative approaches:**
1. **No oversampling:** Complexity LOW, fast CPU, aliasing present at high FOLD
   - Best for: Prototyping, low-end systems
2. **2x oversampling:** Complexity MEDIUM, moderate CPU, reduced aliasing
   - Best for: Performance mode or real-time use
3. **8x oversampling:** Complexity MEDIUM, high CPU, minimal aliasing
   - Best for: Quality mode or offline processing

**Fallback architecture:**
- **Primary:** 4x oversampling with filterHalfBandFIREquiripple (balance quality/CPU)
- **Fallback 1:** If CPU too high → User-selectable 2x/4x/off (quality modes)
- **Fallback 2:** If gain issues → Apply compensating gain (-6dB) after downsampling
- **Fallback 3:** If aliasing still present → Switch to 8x oversampling or research ADAA (anti-derivative anti-aliasing)

**Mitigation strategy:**
1. Test oversampling in isolation (sine sweep → measure aliasing)
2. Benchmark CPU with different factors (2x, 4x, 8x)
3. Measure gain change with white noise (apply compensation if needed)
4. Consider user-configurable oversampling factor (quality vs. performance)
5. Check JUCE forum for best practices on Oversampling class usage

---

### Overall Project Risk

**Overall complexity:** LOW
- Simple transfer functions (MEDIUM) + standard JUCE DSP classes (LOW) + no complex state (LOW)
- 4 parameters, straightforward signal flow, no file I/O or multi-output

**Highest risk component:** Oversampling System
- Represents ~40% of project risk
- JUCE class has known quirks (gain compensation)
- CPU cost may require quality modes
- Most likely source of implementation challenges

**Recommended approach:**
1. **Phase 1 - Validate concept:** Implement single-stage Clean mode without oversampling (validate transfer function)
2. **Phase 2 - Build foundation:** Add multi-stage cascading and dry/wet mixing (validate architecture)
3. **Phase 3 - Add oversampling:** Integrate dsp::Oversampling with gain compensation (address aliasing)
4. **Phase 4 - Polish modes:** Implement Warm and Aggressive modes (tune character)
5. **Phase 5 - Optimize:** Add DC removal, tune parameters, measure CPU

---

## Architecture Decisions

### Wave Folding Algorithm Choice

**Decision:** Use JUCE dsp::WaveShaper with custom transfer functions (lambdas) for three modes

**Rationale:**
- JUCE WaveShaper is standard approach (used in official tutorials)
- Custom transfer functions provide flexibility for three modes
- Sample-by-sample processing matches wave folding requirements
- Clean integration with other dsp:: classes (Oversampling, DryWetMixer)

**Alternatives considered:**
1. **Lookup table (LUT):**
   - Why rejected: Overkill for simple transfer functions, adds complexity (precomputation, interpolation)
   - When to reconsider: If CPU profiling shows transfer function evaluation is bottleneck (unlikely)

2. **Custom inline processing (no WaveShaper class):**
   - Why rejected: Reinventing wheel, WaveShaper is well-tested and optimized
   - When to reconsider: If WaveShaper has unexpected issues or overhead (unlikely)

3. **Third-party waveshaping library:**
   - Why rejected: No need for external dependency, JUCE provides sufficient tools
   - When to reconsider: Never (JUCE is adequate for this use case)

**Tradeoffs accepted:**
- **WaveShaper overhead vs. custom code:** WaveShaper may have slight overhead compared to raw loops
  - Acceptable because: Overhead is minimal, code clarity and maintainability more important
- **Lambda capture for mode switching:** Using std::function with lambdas vs. switch statement
  - Acceptable because: Cleaner code, easier to test each mode independently

**When to revisit:**
- If CPU profiling shows WaveShaper is bottleneck (benchmark first)
- If mode switching causes audio glitches (unlikely with proper implementation)

---

### Oversampling Configuration

**Decision:** Implement 4x oversampling with filterHalfBandFIREquiripple as default

**Rationale:**
- 4x provides strong aliasing reduction without extreme CPU cost (balance)
- FIR equiripple has better aliasing suppression than IIR (slight CPU cost acceptable)
- Industry standard for distortion plugins (FabFilter Saturn, Soundtoys)
- Buchla 259 research (DAFx paper) used 8x with BLAMP, but 4x is acceptable for plugin

**Alternatives considered:**
1. **2x oversampling:**
   - Why rejected: Insufficient aliasing reduction at high FOLD amounts
   - When to reconsider: As "performance mode" option for low-end systems

2. **8x oversampling:**
   - Why rejected: CPU cost too high for default setting (4x CPU increase over 2x)
   - When to reconsider: As "quality mode" option for offline processing or high-end systems

3. **No oversampling:**
   - Why rejected: Aliasing is audible and unprofessional at moderate-to-high FOLD
   - When to reconsider: Never as default (may offer as "CPU saver" mode for emergencies)

4. **ADAA (Anti-Derivative Anti-Aliasing):**
   - Why rejected: More complex implementation, JUCE doesn't provide built-in support
   - When to reconsider: If 4x oversampling proves insufficient or CPU too high

**Tradeoffs accepted:**
- **CPU usage:** 4x oversampling = ~4x CPU compared to no oversampling
  - Acceptable because: Target is studio use (not real-time performance critical), aliasing is unacceptable
- **Latency:** Oversampling adds latency (filter delay ~10-20 samples at 4x)
  - Acceptable because: Wave folding is typically post-processing effect, not tracking
- **Gain compensation needed:** FIR filters may boost gain by ~6dB
  - Mitigation: Measure and apply compensating attenuation after downsampling

**When to revisit:**
- If CPU exceeds 30% single core (consider 2x mode or user-selectable factor)
- If aliasing still audible at 4x (test with spectrum analyzer, consider 8x or ADAA)
- If gain compensation proves problematic (switch to IIR filters despite worse aliasing)

---

### Multi-Stage Cascading Design

**Decision:** Support 1-4 stages with sequential application of same transfer function

**Rationale:**
- Matches Buchla 259 design philosophy (5 parallel stages, but serial is more common in software)
- Exponential harmonic growth provides wide range of timbres
- Simple implementation (loop with same transfer function)
- 4 stages maximum prevents excessive CPU and noise-like character

**Alternatives considered:**
1. **Parallel stages (Buchla 259 style):**
   - Why rejected: More complex mixing logic, less dramatic effect than serial
   - When to reconsider: If users specifically request Buchla 259 accuracy (unlikely for drum-focused plugin)

2. **Fixed 2 stages only:**
   - Why rejected: Reduces user control, 1 stage is useful for subtle effects, 3-4 stages for extreme
   - When to reconsider: Never (no benefit to limiting user flexibility)

3. **Variable stage count (1-8 or continuous):**
   - Why rejected: 4 stages already produces extreme harmonics, more is overkill and CPU waste
   - When to reconsider: If user feedback requests more stages (unlikely)

**Tradeoffs accepted:**
- **CPU scales with stages:** 4 stages = 4x CPU for folding loop (not including oversampling)
  - Acceptable because: User has control, 1-2 stages is typical use case, 4 stages is "extreme mode"
- **Harmonic density may become noisy:** 4 stages at high FOLD creates very dense harmonics
  - Acceptable because: This is by design (extreme destruction), users can reduce STAGES or FOLD

**When to revisit:**
- If CPU profiling shows stage loop is bottleneck (optimize transfer function evaluation)
- If users report 4 stages is insufficient (add 5-6 stages, unlikely)
- If users find 4 stages too noisy (document as "extreme mode", suggest 2-3 stages)

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()`
- Transfer function evaluation is stateless (no shared memory)
- Oversampling buffers are per-instance (no thread conflicts)
- No mutex needed (all processing in audio thread)

### Performance
- **Wave folding (per stage):** ~1-2% CPU (simple math operations)
- **Oversampling (4x):** ~15-20% CPU (FIR filters + upsample/downsample)
- **DC removal filter:** ~1% CPU (first-order IIR)
- **Dry/wet mixing:** ~1% CPU (linear interpolation)
- **Total estimated:** ~20-25% single core at 48kHz with 4 stages + 4x oversampling
- **Hot path:** Oversampling filters (most expensive), transfer function loop (4 stages)

### Denormal Protection
- Use `juce::ScopedNoDenormals` in processBlock()
- Transfer functions use abs() and bounded math (no denormal generation)
- DC removal filter may generate denormals (handled by ScopedNoDenormals)

### Sample Rate Handling
- Oversampling adapts to host sample rate automatically (dsp::Oversampling handles this)
- DC removal filter cutoff (20Hz) is sample rate independent (recalculated in prepareToPlay)
- Transfer functions are sample rate independent (operate on normalized signal)
- prepareToPlay() requirements:
  - Initialize Oversampling with ProcessSpec
  - Initialize DC removal filter coefficients
  - Initialize DryWetMixer with buffer size

### Latency
- **Oversampling latency:** ~10-20 samples at host rate (FIR filter delay)
- **DC removal filter:** Negligible (first-order IIR)
- **Total latency:** ~10-20 samples at 48kHz (~0.2-0.4ms)
- Report via `getLatencySamples()` for host compensation
- DryWetMixer handles latency compensation automatically (aligns dry signal with wet)

---

## Research References

### Professional Plugins
1. **Newfangled Audio "Bent 259" (in Generate synth)**
   - Buchla 259 wavefolder emulation using "Model Bending" technique
   - Uses 5 center-clipping waveshapers with different slopes/offsets
   - Anti-aliasing via anti-derivative anti-aliasing (ADAA) instead of oversampling
   - Source: [Model Bending the Buchla 259 Wavefolder](https://www.newfangledaudio.com/post/model-bending-the-buchla-259-wavefolder)

2. **apulSoft apShaper**
   - Five high-quality waveshaping engines including wavefold
   - Extremely low aliasing (likely heavy oversampling or ADAA)
   - Symmetrical and asymmetrical user-editable breakpoints
   - Source: [apulSoft apShaper](https://www.apulsoft.ch/apshaper/)

3. **AudioThing Wave Box**
   - Dynamic dual waveshaper plugin
   - Symmetrical and asymmetrical distortion modes
   - Source: [Wave Box Plugin](https://www.audiothing.net/effects/wave-box/)

4. **FabFilter Saturn 2**
   - Multiband distortion/saturation with 28 different distortion styles
   - Includes wavefold-style distortion modes
   - Extensive modulation and oversampling options
   - Source: [FabFilter Saturn 2](https://www.fabfilter.com/products/saturn-2-multiband-distortion-saturation-plug-in)

### JUCE Documentation
- **juce::dsp::WaveShaper:** Template struct for applying waveshaping transfer functions
  - Works with single samples or AudioBlocks
  - Accepts std::function for custom transfer functions
  - Source: [JUCE WaveShaper Documentation](https://docs.juce.com/master/structdsp_1_1WaveShaper.html)

- **juce::dsp::Oversampling:** Handles upsampling and downsampling for nonlinear processing
  - Reduces aliasing from waveshaping/distortion
  - Two filter types: filterHalfBandPolyphaseIIR, filterHalfBandFIREquiripple
  - FIR has better aliasing suppression but slightly higher CPU
  - Note: May introduce gain change (~6dB with FIR filters), compensate if needed
  - Source: [JUCE Oversampling.h](https://github.com/WeAreROLI/JUCE/blob/master/modules/juce_dsp/processors/juce_Oversampling.h)

- **juce::dsp::DryWetMixer:** Latency-compensated dry/wet blending
  - Handles delay introduced by oversampling automatically
  - Source: JUCE DSP module documentation

- **juce::dsp::IIR::Filter:** Infinite impulse response filters for DC removal
  - First-order high-pass at 20Hz sufficient for DC offset removal
  - Source: JUCE DSP module documentation

### Technical Resources
- **DAFx-17 Paper: "Virtual Analog Buchla 259 Wavefolder"**
  - Academic research on antialiased digital model of Buchla 259
  - Uses bandlimited ramp (BLAMP) method with 8x oversampling
  - Memoryless mappings of input-output voltage relationships
  - Source: [DAFx-17 Paper](https://www.dafx17.eca.ed.ac.uk/papers/DAFx17_paper_82.pdf)

- **JUCE Official Tutorial: "Add distortion through waveshaping and convolution"**
  - Demonstrates dsp::WaveShaper usage with transfer functions
  - Example of Gain processors around WaveShaper
  - Source: [JUCE Waveshaping Tutorial](https://juce.com/tutorials/tutorial_dsp_convolution/)

- **Modular Community Discussions:**
  - Intellijel Bifold: Parallel (Buchla) and serial (Serge) wavefolder comparison
  - Serge vs. Buchla folding characteristics (serial more dramatic, parallel smoother)
  - Source: [MOD WIGGLER Wavefolder Discussion](https://modwiggler.com/forum/viewtopic.php?t=250238)

---

## Notes

- **Transfer function choice rationale:** Clean mode for precision (drums), Warm for musicality (snares), Aggressive for bite (hi-hats)
- **Oversampling gain compensation:** Test with white noise, measure peak level, apply compensating attenuation if needed
- **DC offset removal placement:** Must be after folding but before downsampling (more effective at higher rate)
- **Stage count exponential behavior:** Each additional stage squares the harmonic density (1→2→4→8 pattern roughly)
- **CPU optimization opportunities:** If needed, use lookup table for transfer functions or reduce oversampling factor
- **Testing approach:** Sine sweep (20Hz-20kHz) through spectrum analyzer to visualize harmonics and aliasing
- **Parameter tuning:** May need to adjust pre-gain formula (1.0-10.0 range) based on listening tests
- **Buchla 259 accuracy note:** This plugin uses serial cascading (more common in software) rather than parallel mixing (true Buchla 259). Sonic character inspired by Buchla but not a direct emulation.
